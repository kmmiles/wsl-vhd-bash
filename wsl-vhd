#!/bin/bash
#
# VHD management for WSL.
################################################################################
set -uo pipefail

################################################################################
# globals
################################################################################
PROG_NAME="$(basename "$0")"

LOG_LEVEL_UNSET=0
LOG_LEVEL_DEBUG=10
LOG_LEVEL_INFO=20
LOG_LEVEL_WARN=30
LOG_LEVEL_ERROR=40
LOG_LEVEL_CRITICAL=40
LOG_LEVEL=$LOG_LEVEL_WARN

ERR_SUCCESS=0
ERR_GENERAL=1
ERR_FILE_NOT_FOUND=2
ERR_ALREADY_ATTACHED=3
ERR_ALREADY_MOUNTED=4
ERR_NOT_MOUNTED=5
ERR_ATTACHED_NOT_MOUNTED=6
ERR_NOT_FORMATTED=7
ERR_BAD_FILE_EXT=8
ERR_UNMOUNT=9
ERR_DEVICE_MISSING=10
ERR_BUSY=11

################################################################################
# Usage: strerror <errno>
#
# Print string describing <errno>
################################################################################
strerror() {
  case "${1:-$ERR_GENERAL}" in
    "$ERR_SUCCESS") printf "Success" ;;
    "$ERR_GENERAL") printf 'General error' ;;
    "$ERR_FILE_NOT_FOUND") printf 'File not found' ;;
    "$ERR_ALREADY_ATTACHED") printf 'Already attached' ;;
    "$ERR_ALREADY_MOUNTED") printf 'Already mounted' ;;
    "$ERR_NOT_MOUNTED") printf 'Not mounted' ;;
    "$ERR_ATTACHED_NOT_MOUNTED") printf 'Attached, but failed to mount' ;;
    "$ERR_NOT_FORMATTED") printf 'Not formatted' ;;
    "$ERR_BAD_FILE_EXT") printf 'Invalid file extension (must be .vhdx)' ;;
    "$ERR_UNMOUNT") printf 'Could not unmount' ;;
    "$ERR_DEVICE_MISSING") printf 'Device missing' ;;
    "$ERR_BUSY") printf 'Windows is using the VHD (try ejecting)' ;;
    *) printf 'Unknown error %s' "${1:-}" ;;
  esac
}

################################################################################
# logging functions
#
# Each prints all passed parameters as a string to `stderr`, if the global
# $LOG_LEVEL is set accordingly. See `main` for how $LOG_LEVEL is adjusted.
################################################################################
logging::debug() {
  if ((LOG_LEVEL <= LOG_LEVEL_DEBUG)); then
    printf >&2 'DEBUG: [%s] %s\n' "${FUNCNAME[1]}" "$*"
  fi
}

logging::info() {
  if ((LOG_LEVEL <= LOG_LEVEL_INFO)); then
    printf >&2 'INFO: [%s] %s\n' "${FUNCNAME[1]}" "$*"
  fi
}

logging::warning() {
  if ((LOG_LEVEL <= LOG_LEVEL_WARN)); then
    printf >&2 'WARNING: [%s] %s\n' "${FUNCNAME[1]}" "$*"
  fi
}

logging::error() {
  if ((LOG_LEVEL <= LOG_LEVEL_ERROR)); then
    printf >&2 'ERROR: [%s] %s\n' "${FUNCNAME[1]}" "$*"
  fi
}

logging::critical() {
  if ((LOG_LEVEL <= LOG_LEVEL_CRITICAL)); then
    printf >&2 'CRITICAL: [%s] %s\n' "${FUNCNAME[1]}" "$*"
  fi
}

################################################################################
# Usage: array::sort <params>
#
# Prints each parameter in sorted order
################################################################################
array::sort() { printf '%s\n' "$@" | LC_ALL=C sort; }

################################################################################
# Usage: array::diff <array1> <array2>
#
# Prints elements that exist in array2, which do not exist in array1.
# Arrays are passed by name.
################################################################################
array::diff() {
  local -n arr1=$1
  local -n arr2=$2
  comm -13 <(array::sort "${arr1[@]}") <(array::sort "${arr2[@]}")
}

################################################################################
# Usage: path::win::is_extlen <winpath>
#
# Returns success if <winpath> includes the Extended Length Prefix.
# <https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file>
################################################################################
path::win::is_extlen() {
  local s="${1:-}"
  [[ "${s:0:4}" == "\\\\?\\" ]]
}

################################################################################
# Usage: path::win::strip_extlen <winpath>
#
# Prints <winpath>, omitting the Extended Length Prefix if one exists.
################################################################################
path::win::strip_extlen() {
  local path="${1:-}"
  if path::win::is_extlen "$path"; then
    printf '%s\n' "${path:4}"
  else
    printf '%s\n' "$path"
  fi
}

################################################################################
# Usage: path::win::add_extlen <winpath>
#
# Prints <winpath>, adding the Extended Length Prefix if none exists.
################################################################################
path::win::add_extlen() {
  local path="${1:-}"
  if path::win::is_extlen "$path" || path::win::is_unc "$path"; then
    printf '%s\n' "$path"
  else
    printf '%s\n' "\\\\?\\$path"
  fi
}

################################################################################
# Usage: path::win::is_unc <winpath>
#
# Returns success if <winpath> is a UNC path e.g. `\\somemachine\file.txt`
################################################################################
# shellcheck disable=SC1003
path::win::is_unc() { ! path::win::is_extlen && [[ "${1:0:2}" == '\\' ]]; }

################################################################################
# Usage: path::unix::tilde <unixpath>
#
# Prints <unixpath>, expanding the `~` character to `$HOME`
################################################################################
path::unix::tilde() {
  local path="${1:-}"
  [[ -n "$path" ]] || return 1
  [[ -n "${HOME:-/root}" ]] || return 1
  # FIXME: doesn't handle ~user

  if [[ $path =~ ^~ ]]; then
    printf '%s\n' "${HOME:-/root}${path:1}"
  else
    printf '%s\n' "$path"
  fi
}

################################################################################
# Usage: path::is_win <path>
#
# Returns success if <path> is a Windows path.
################################################################################
path::is_win() {
  local path="${1:-}"
  [[ -n "$path" ]] || return 1
  path::win::is_extlen "$path" \
    || [[ $path =~ ^[a-zA-Z]:\\ ]] \
    || [[ $path =~ ^\.\\ ]]
}

################################################################################
# Usage: path::to_win [options] <path>
#
# Prints path, converting it to Windows format.
#
# [options]
#
# -a  Convert path to absolute
# -e  Add the Extended Length Prefix
################################################################################
path::to_win() {
  local OPTIND absolute=false extlen=false
  while getopts 'ae' flag; do
    case "${flag}" in
      a) absolute=true ;;
      e) extlen=true ;;
      *)
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local path="${1:-}"
  if [[ -z "$path" ]]; then
    return 1
  fi
  shift 1

  if ! path::is_win "$path"; then
    path="$(path::unix::tilde "$path")"
    if $absolute; then
      path="$(wslpath -wa "$path")"
    else
      path="$(wslpath -w "$path")"
    fi
  fi

  if $extlen; then
    path="$(path::win::add_extlen "$path")"
  else
    path="$(path::win::strip_extlen "$path")"
  fi

  printf '%s\n' "$path"
}

################################################################################
# Usage: path::to_unix [options] <path>
#
# Prints <path>, converting it to "unix" format.
#
# [options]
#
# -a  Convert path to absolute
# -e  Add the Extended Length Prefix
################################################################################
path::to_unix() {
  local OPTIND absolute=false
  while getopts 'a' flag; do
    case "${flag}" in
      a) absolute=true ;;
      *)
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local path="${1:-}"
  if [[ -z "$path" ]]; then
    return 1
  fi
  shift 1

  if path::is_win "$path"; then
    path=$(wslpath -u "$(path::win::strip_extlen "$path")")
  else
    path="$(path::unix::tilde "$path")"
  fi

  if $absolute; then path="$(realpath -sm "$path")"; fi

  printf '%s\n' "$path"
}

################################################################################
# Usage: sys::wsl <parameters>
#
# Executes `wsl.exe <parameters>` and returns smarter errors codes.
################################################################################
sys::wsl() {
  # XXX: Due to WSL interop, output from `wsl.exe` contains a NULL between every character.
  #PATH=$PATH:"/mnt/c/WINDOWS/system32" out="$(wsl.exe "$@" 2>/dev/null)"

  PATH=$PATH:"/mnt/c/WINDOWS/system32" out="$(wsl.exe "$@" 2>&1 | tr -d '\0')"
  local rc=$?
  logging::debug "wsl.exe $* returned $rc"
  logging::debug "$out"
  if ((rc != 0)); then
    if grep -q "WSL_E_USER_VHD_ALREADY_ATTACHED" <<<"$out"; then
      return $ERR_ALREADY_ATTACHED
    elif grep -q "ERROR_FILE_NOT_FOUND" <<<"$out"; then
      return $ERR_FILE_NOT_FOUND
    elif grep -q "ERROR_PATH_NOT_FOUND" <<<"$out"; then
      return $ERR_FILE_NOT_FOUND
    elif grep -q "it is being used by another process" <<<"$out"; then
      return $ERR_BUSY
    #elif grep -q "The disk was attached but failed to mount: No such device" <<<"$out"; then
    #  return $ERR_ATTACHED_NOT_MOUNTED
    elif grep -q "attached but failed to mount" <<<"$out"; then
      return $ERR_ATTACHED_NOT_MOUNTED
    else
      return $ERR_GENERAL
    fi
  fi
}

################################################################################
# Usage: sys::fstype <device>
#
# Print the underlying filesystem type of <device> or `none` on failure.
################################################################################
sys::fstype() {
  local device="${1:-}"
  [[ -n "$device" ]] || return 1
  if [[ "${device:0:5}" != "/dev/" ]]; then device="/dev/$device"; fi
  sudo blkid --probe --usages filesystem --match-tag TYPE \
    --output value "$device" 2>/dev/null || printf 'none\n'
}

################################################################################
# Usage: sys::devices
#
# Prints path of each block device, skipping partitions e.g. `/dev/sdd1`.
################################################################################
sys::devices() {
  lsblk --ascii --noheadings --output NAME | grep -vE "^\`-" | while read -r device_name; do
    printf '/dev/%s\n' "$device_name"
  done
}

################################################################################
# Usage: sys::mounts
#
# Prints device path of every mount, skipping any that don't start with `/dev/`
################################################################################
sys::mounts() { cut -d' ' -f 1 /proc/mounts | grep -E "^/dev/" | sort -u; }

################################################################################
# Usage: sys::mount <device> <mountpoint>
#
# Mount <device> to <mountpoint> using `mount`.
#
# XXX: This is exclusively for NTFS filesystems. The WSL kernel doesn't ship
# with NTFS support by default; WSL can only attach the device, not mount it.
# So we rely on the FUSE userland driver and `mount` it ourselves .
################################################################################
sys::mount() {
  local device="${1:-}"
  [[ -n "$device" ]] || return 1
  local mountpoint="${2:-}"
  [[ -n "$mountpoint" ]] || return 1
  if [[ "${device:0:5}" != "/dev/" ]]; then device="/dev/$device"; fi

  mkdir -p "$mountpoint" || return 1
  if ! out=$(sudo mount "$device" "$mountpoint"); then
    logging::debug "$out"
    return 1
  fi
}

################################################################################
# Usage: sys::unmount <device>
#
# Unmount <device> using `umount`.
#
# XXX: This is exclusively for NTFS filesystems (see sys::mount)
################################################################################
sys::unmount() {
  local device="${1:-}"
  [[ -n "$device" ]] || return 1
  sudo umount --all-targets "$device" >/dev/null 2>&1 || return $ERR_UNMOUNT
}

################################################################################
# Usage: sys::device_exists <device>
#
# Returns success if <device> exists. See `vhd::broken_mount`.
################################################################################
sys::device_exists() {
  local device="${1:-}"
  [[ -n "$device" ]] && [[ -b "$device" ]]
}

################################################################################
# Usage: sys::filesystems
#
# Print supported filesystems, one per line.
################################################################################
sys::filesystems() {
  while read -ra vals; do
    [[ "${vals[0]}" == "nodev" ]] && continue
    if PATH=/sbin:/usr/sbin command -v "mkfs.${vals[0]}" >/dev/null 2>&1; then
      printf '%s\n' "${vals[0]}"
    else
      logging::info "mkfs.${vals[0]} not found (package not installed?)"
    fi
  done < <(sort -d /proc/filesystems)

  # ntfs is an exception, because we're using a FUSE userland driver.
  # TODO: Should look at other potential FUSE filesystems.
  if PATH=/sbin:/usr/sbin command -v "mkfs.ntfs" >/dev/null 2>&1; then
    printf 'ntfs\n'
  else
    logging::info "mkfs.ntfs not found (package not installed?)"
  fi
}

################################################################################
# Usage: sys::format <device> <fstype>
#
# Format <device> with `mkfs.$fstype`.
#
# If <fstype> is `ntfs`, a partition will be created on <device>, which will be
# formatted instead. If we create it on the device, as every other filesystem,
# Windows will be unable to read it.
################################################################################
sys::format() {
  local device="${1:-}"
  [[ -n "$device" ]] || return 1
  local fstype="${2:-}"
  [[ -n "$fstype" ]] || return 1

  mkfsargs=("-t" "$fstype")
  if [[ "$fstype" == "ntfs" ]]; then
    mkfsargs+=("-f")
    if ! out=$(printf 'n\np\n1\n\n\nt 1\n7\nw\n' | sudo fdisk "$device" 2>&1); then
      logging::debug "$out"
      return $ERR_GENERAL
    fi
    device="${device}1"
  fi
  mkfsargs+=("$device")

  out=$(sudo mkfs "${mkfsargs[@]}" 2>&1) || {
    logging::debug "$out"
    return $ERR_GENERAL
  }
}

################################################################################
# Usage: sys::requirements
#
# Check system requirements and log errors if we don't meet them.
################################################################################
sys::requirements() {
  requirements=('sudo' 'qemu-img' 'mkfs.ntfs')
  for requirement in "${requirements[@]}"; do
    if ! command -v "$requirement" >/dev/null 2>&1; then
      logging::error "Required program missing $requirement"
      logging::error "Ubuntu/Debian: sudo apt install qemu-utils ntfs-3g"
      logging::error "Redhat: sudo dnf install ntfsprogs"
      return 1
    fi
  done
  logging::debug "All requirements satisfied."
}

################################################################################
# Usage: vhd::unixpath <vhd>
#
# Prints path to <vhd> in "unix" format.
################################################################################
vhd::unixpath() { path::to_unix -a "${1:-}"; }

################################################################################
# Usage: vhd::winpath <vhd>
#
# Prints path to <vhd> in Windows format (including the Extended Length Prefix).
################################################################################
vhd::winpath() { path::to_win -e "${1:-}"; }

################################################################################
# Usage: vhd::name <vhd>
#
# Prints the "name" of the vhd; it's unix basename minus extension. The name is
# as part of the mountpoint.
#
# Example: `C:\foobar.vhdx` will have the name `foobar`.
################################################################################
vhd::name() {
  filename=$(basename "$(vhd::unixpath "${1:-}")")
  printf '%s\n' "$(basename "$filename" ".${filename#*.}")"
}

################################################################################
# Usage: vhd::mountpoint <vhd>
#
# Prints the mountpoint of <vhd> (whether it's mounted or not)
#
# Example: `C:\foobar.vhdx` will have a mountpath of `/mnt/wsl/foobar`.
################################################################################
vhd::mountpoint() { printf '/mnt/wsl/%s\n' "$(vhd::name "${1:-}")"; }

################################################################################
# Usage: vhd::exists <vhd>
#
# Returns success if the <vhd> file exists.
################################################################################
vhd::exists() {
  local path="${1:-}"
  [[ -n "$path" ]] || return 1
  if [[ ! -f "$(vhd::unixpath "$path")" ]]; then
    logging::debug "$path: $(strerror $ERR_FILE_NOT_FOUND)"
    return 1
  fi
}

################################################################################
# Usage: vhd::is_mounted <vhd>
#
# Returns success if the <vhd> is mounted, and prints the device it's mounted to
################################################################################
vhd::is_mounted() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1

  local mountpoint
  mountpoint="$(vhd::mountpoint "$vhd")" || return 1
  [[ -n "$mountpoint" ]] || return 1

  local device_name
  device_name="$(findmnt -n -f "$mountpoint" | cut -d' ' -f 2 | cut -b6-)" || return 1
  [[ -n "$device_name" ]] || return 1

  printf '/dev/%s\n' "$device_name"
}

################################################################################
# Usage: vhd::chown <vhd> [user] [group]
#
# Changes ownership of <vhd>'s mountpoint.
#
# XXX: <vhd> should be mounted first, but that's callers responsibility.
################################################################################
vhd::chown() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  local user="${2:-}"
  local group="${3:-}"
  if [[ -n "$user" ]]; then sudo chown "$user" "$(vhd::mountpoint "$vhd")" || return 1; fi
  if [[ -n "$group" ]]; then sudo chgrp "$group" "$(vhd::mountpoint "$vhd")" || return 1; fi
}

################################################################################
# Usage: vhd::mount <vhd>
#
# Mounts <vhd>
################################################################################
vhd::mount() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  local device pre post fstype

  vhd::exists "$vhd" || return $ERR_FILE_NOT_FOUND
  if device=$(vhd::is_mounted "$vhd"); then
    printf '%s\n' "$device"
    return $ERR_ALREADY_MOUNTED
  fi

  readarray -t pre < <(sys::devices)
  local rc=0
  sys::wsl --mount --vhd --name "$(vhd::name "$vhd")" "$(vhd::winpath "$vhd")" || rc=$?
  readarray -t post < <(sys::devices)
  device="$(array::diff pre post | head -n 1)"

  # XXX: We tried to mount it, but it came back attached but not mounted.
  # If there's a filesystem, try to mount it manually with `mount`.
  if ((rc == ERR_ATTACHED_NOT_MOUNTED)); then
    [[ -n "$device" ]] || return $rc

    # XXX: If the device has partition 1, use it instead of the root device.
    # NTFS is the only filesystem type to use/need a partition.
    if [[ -b "${device}1" ]]; then device="${device}1"; fi

    # quit if can't find a valid filesystem
    fstype=$(sys::fstype "$device") || return $ERR_GENERAL
    if [[ "$fstype" == "none" ]]; then return $ERR_NOT_FORMATTED; fi
    # do the manual mount
    sys::mount "$device" "$(vhd::mountpoint "$vhd")" || return $ERR_GENERAL
  elif ((rc != 0)); then
    return $rc
  fi

  printf '%s\n' "$device"
}

################################################################################
# Usage: vhd::attach <vhd>
#
# Attaches <vhd> and prints the device on success.
# The device will be exposed to WSL, but not mounted.
################################################################################
vhd::attach() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  local device pre post

  vhd::exists "$vhd" || return $ERR_FILE_NOT_FOUND

  if device=$(vhd::is_mounted "$vhd"); then
    printf '%s\n' "$device"
    return $ERR_ALREADY_MOUNTED
  fi

  # shellcheck disable=SC2034
  readarray -t pre < <(sys::devices)
  sys::wsl --mount --bare --vhd --name "$(vhd::name "$vhd")" "$(vhd::winpath "$vhd")" || return $?

  # shellcheck disable=SC2034
  readarray -t post < <(sys::devices)
  printf '%s\n' "$(array::diff pre post | head -n 1)"
}

################################################################################
# Usage: vhd::broken_mount <vhd>
#
# Returns success if <vhd> has a broken mount. This means the device is mounted,
# but doesn't exist. This can happen if `wsl.exe --unmount` detaches the device,
# but fails to unmount it (which is the case for any device manually mounted
# with `mount`, like NTFS).
################################################################################
vhd::broken_mount() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  [[ -f "$(vhd::unixpath "$vhd")" ]] || return 1
  device=$(vhd::is_mounted "$vhd") || return 1
  if ! sys::device_exists "$device"; then printf '%s\n' "$device"; fi
}

################################################################################
# Usage: vhd::mountpoints
#
# Prints the mountpoint of every mounted vhd.
################################################################################
vhd::mountpoints() {
  local mountpoint
  while read -ra arr; do
    mountpoint="${arr[1]}"
    if [[ "${mountpoint:0:9}" == '/mnt/wsl/' ]]; then
      printf '%s\n' "${arr[1]}"
    fi
  done </proc/mounts
}

################################################################################
# Usage: vhd::unmount <vhd>
#
# Unmounts <vhd>.
################################################################################
vhd::unmount() {
  local vhd="${1:-}"
  local device

  # no vhd passed....so unmount everything.
  if [[ -z "$vhd" ]]; then
    sys::wsl --unmount || :
    while read -r mountpoint; do
      [[ -n "$mountpoint" ]] || continue
      sys::unmount "$mountpoint" || :
    done < <(vhd::mountpoints)
    return 0
  fi

  # vhd passed....so unmount it.
  vhd="$(vhd::unixpath "$vhd")"
  if [[ "${vhd#*.}" != "vhdx" ]]; then
    logging::error "$(strerror "$ERR_BAD_FILE_EXT")"
    return $ERR_BAD_FILE_EXT
  fi

  sys::wsl --unmount "$(vhd::winpath "$vhd")" || :
  sys::unmount "$(vhd::mountpoint "$vhd")" || :
}

################################################################################
# Usage: vhd::create <vhd> <size_in_mb>
#
# Creates <vhd> with `qemu-img`.
################################################################################
vhd::create() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  local size_in_mb="${2:-}"
  [[ -n "$size_in_mb" ]] || return 1

  if [[ -f "$(vhd::unixpath "$vhd")" ]]; then return 1; fi
  [[ "${vhd#*.}" == "vhdx" ]] || return $ERR_BAD_FILE_EXT

  vhd::unmount "$vhd" || :
  if ! out="$(qemu-img create -f vhdx "$(vhd::unixpath "$vhd")" "${size_in_mb}M" 2>&1)"; then
    logging::debug "$out"
    return 1
  fi
}

################################################################################
# Usage: vhd::format <vhd> <fstype>
#
# Formats <vhd> with <fstype>. If the <vhd> is currently mounted, it will be
# unmounted.
################################################################################
vhd::format() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  local fstype="${2:-}"
  [[ -n "$fstype" ]] || return 1

  # unmount and attach
  vhd::unmount "$vhd" || :
  device=$(vhd::attach "$vhd") || return $?

  # format and unmount
  sys::format "$device" "$fstype" || return $?
  vhd::unmount "$vhd" || :
}

################################################################################
# Usage: vhd::use <vhd> <fstype> <size_in_mb>
#
# Mounts <vhd>. If <vhd> doesn't exist, it will created and formatted first.
################################################################################
vhd::use() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  local fstype="${2:-}"
  [[ -n "$fstype" ]] || return 1
  local size_in_mb="${3:-}"
  [[ -n "$size_in_mb" ]] || return 1
  local rc

  logging::debug "$*"
  device=$(vhd::mount "$vhd") || {
    rc=$?
    case $rc in
      "$ERR_FILE_NOT_FOUND")
        vhd::create "$vhd" "$size_in_mb" || return $?
        vhd::format "$vhd" "$fstype" || return $?
        vhd::mount "$vhd" >/dev/null || return $?
        ;;
      *) return $rc ;;
    esac
  }
  vhd::chown "$vhd" "${user:-}" "${group:-}" || :
  printf '%s\n' "$device"
}

################################################################################
# cli functions.
#################################################################################

wsl-vhd-use() {
  logging::debug "wsl-vhd use $*"
  usage() {
    cat <<EOF
Usage: $PROG_NAME use <VHD> <FS_TYPE> <SIZE_IN_MB> [...]

Mounts VHD's, creating and formatting if necessary.

OPTIONS

-u  <USER>  Change owner of mountpoint to <USER> 
-u  <GROUP> Change group of mountpoint to <GROUP> 
-h          This message

EXAMPLES

$ $PROG_NAME use /mnt/c/wsl-vhd/code.vhdx btrfs 2000

$ $PROG_NAME use \\
	/mnt/c/wsl-vhd/1G-btrfs.vhdx btrfs 1000 \\
	/mnt/c/wsl-vhd/2G-ext4.vhdx ext4 2000 \\
	/mnt/c/wsl-vhd/3G-ntfs.vhdx ntfs 3000
EOF
  }

  local OPTIND
  local user group fstype rc

  if (($(id -u) != 0)); then user=$(id -un); fi
  if (($(id -g) != 0)); then group=$(id -gn); fi

  while getopts 'u:g:h' flag; do
    case "${flag}" in
      u) user="$OPTARG" ;;
      g) group="$OPTARG" ;;
      *)
        usage
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))

  if (($# == 0 || $# % 3 != 0)); then
    usage
    return 1
  fi

  local lasterr=0
  local lastvhd=
  while (($# >= 3)); do
    local vhd="${1:-}"
    [[ -n "$vhd" ]] || {
      usage
      return 1
    }

    local fstype="${2:-}"
    [[ -n "$fstype" ]] || {
      usage
      return 1
    }

    local size_in_mb="${3:-}"
    [[ -n "$size_in_mb" ]] || {
      usage
      return 1
    }

    shift 3

    vhd::use "$vhd" "$fstype" "$size_in_mb" >/dev/null || {
      rc=$?
      if ((rc != 0 && rc != ERR_ALREADY_MOUNTED)); then
        logging::error "$vhd: $(strerror $rc)"
        return $lasterr
      else
        logging::info "$vhd: Succesfully mounted."
      fi
    }
  done
}

wsl-vhd-create() {
  usage() {
    cat <<EOF
Usage: $PROG_NAME <VHD> <SIZE_IN_MB>

Create a new <VHD>, <SIZE_IN_MB> megabytes large. 
This simply creates the image, not the filesystem.

EXAMPLES

$ $PROG_NAME create /mnt/c/code.vhdx
EOF
  }

  local OPTIND
  while getopts 'h' flag "$@"; do
    case "${flag}" in
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local vhd="${1:-}"
  local size_in_mb="${2:-}"
  shift 2

  if [[ -z "$vhd" ]] || [[ -z "$size_in_mb" ]]; then
    usage
    return 1
  fi

  local rc
  vhd::create "$vhd" "$size_in_mb" || {
    rc=$?
    logging::error "$vhd: Failed to create ${size_in_mb} image: $(strerror $rc)"
    return $rc
  }

  logging::info "$vhd: Successfully created ${size_in_mb}M image"
}

wsl-vhd-format() {
  logging::debug "wsl-vhd format $*"
  usage() {
    cat <<EOF
Usage: $PROG_NAME format <DEVICE> <FS>

Format <DEVICE> with <FS>

Supported filesystems: $(sys::filesystems | tr '\n' ' ')
EOF
  }

  local OPTIND
  while getopts 'h' flag "$@"; do
    case "${flag}" in
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local device="${1:-}"
  local fstype="${2:-}"
  shift 2

  if [[ -z "$device" ]] || [[ -z "$fstype" ]]; then
    usage
    return 1
  fi

  local rc
  vhd::format "$vhd" >/dev/null || {
    rc=$?
    logging::error "$vhd: $(strerror $rc)"
    return $rc
  }

  logging::info "$vhd: Formatted as $fstype"
}

wsl-vhd-mount() {
  logging::debug "wsl-vhd mount $*"
  usage() {
    cat <<EOF
Usage: $PROG_NAME mount <VHD>

Mounts the disk image located at <VHD> and prints the mountpoint on success.

EXAMPLES

$ $PROG_NAME mount /mnt/c/code.vhdx
/mnt/wsl/code
EOF
  }

  local OPTIND
  while getopts 'h' flag "$@"; do
    case "${flag}" in
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local vhd="${1:-}"
  shift 1

  if [[ -z "$vhd" ]]; then
    usage
    return 1
  fi

  local rc
  device="$(vhd::mount "$vhd")" || {
    rc=$?
    logging::error "$vhd: $(strerror $rc)"
    return $rc
  }

  logging::info "$vhd: Mounted at $device"
}

wsl-vhd-attach() {
  usage() {
    cat <<EOF
Usage: $PROG_NAME attach <VHD>

Attach the disk image <VHD> and prints the device on success.

EXAMPLE

$ $PROG_NAME attach 'C:\\mything.vhdx'
/dev/sdd
EOF
  }

  local OPTIND
  while getopts 'h' flag "$@"; do
    case "${flag}" in
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local vhd="${1:-}"
  shift 1

  if [[ -z "$vhd" ]]; then
    usage
    return 1
  fi

  local rc
  device="$(vhd::attach "$vhd")" || {
    rc=$?
    logging::error "$vhd: $(strerror $rc)"
    return $rc
  }

  logging::info "$vhd: Attached to $device"
}

wsl-vhd-unmount() {
  usage() {
    cat <<EOF
Usage: $PROG_NAME unmount [VHD]

Unmount <VHD> or all VHD's
EOF
  }

  local OPTIND
  while getopts 'h' flag "$@"; do
    case "${flag}" in
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local vhd="${1:-}"
  shift 1

  if ! vhd::unmount "$vhd"; then
    logging::info "${vhd:-All}: $(strerror "$ERR_UNMOUNT")"
    return $ERR_UNMOUNT
  fi
}

################################################################################
# main
################################################################################

main() {
  usage() {
    cat <<EOF
Usage: $PROG_NAME [GLOBAL-OPTIONS] <COMMAND>

VHD management for WSL. 

GLOBAL OPTIONS

  -h  This message
  -v  Increase verbosity. \`-vv\` for debug, \`-vvv\` for extended debug.

COMMANDS

  use           Mount VHD's, creating and formatting if necessary
  create        Create new VHD without formatting
  attach        Attach VHD without mounting (aka bare mount)
  mount         Mount VHD
  format        Format VHD
  unmount       Unmount VHD (or all by default)
  compact       Compact VHD (aka sparsify)

Pass \`-h\` to any command to view usage e.g. \`$PROG_NAME use -h\`
EOF
  }

  local OPTIND
  while getopts 'hv' flag; do
    case "${flag}" in
      v) ((LOG_LEVEL -= 10)) || : ;;
      *)
        usage
        return 1
        ;;
    esac
  done

  if ((LOG_LEVEL <= LOG_LEVEL_UNSET)); then
    set -x
  fi

  shift $((OPTIND - 1))
  cmd="${1:-}"
  if [[ -z "$cmd" ]]; then
    usage
    return 1
  fi
  shift 1

  if [[ "$cmd" != "requirements" ]] && ! sys::requirements; then
    logging::critical "Missing requirements"
    return 1
  fi

  case "$cmd" in
    use) wsl-vhd-use "$@" ;;
    create) wsl-vhd-create "$@" ;;
    mount) wsl-vhd-mount "$@" ;;
    attach) wsl-vhd-attach "$@" ;;
    unmount) wsl-vhd-unmount "$@" ;;
    umount) wsl-vhd-unmount "$@" ;;
    format) wsl-vhd-format "$@" ;;
    filesystems) sys::filesystems "$@" ;;
    requirements) sys::requirements "$@" ;;
    test) test::unit "$@" ;;
    *)
      usage
      return 1
      ;;
  esac
}

main "$@"
