#!/bin/bash
#
# VHD management for WSL.
################################################################################
set -uo pipefail

################################################################################
# globals
################################################################################
PROG_NAME="$(basename "$0")"
MOUNT_ROOT="/mnt/wsl" # XXX: If you changed automount.root in /etc/wsl.conf

LOG_LEVEL_UNSET=0
LOG_LEVEL_DEBUG=10
LOG_LEVEL_INFO=20
LOG_LEVEL_WARN=30
LOG_LEVEL_ERROR=40
LOG_LEVEL_CRITICAL=40
LOG_LEVEL=$LOG_LEVEL_INFO

ERR_SUCCESS=0
ERR_GENERAL=1
ERR_ARGS=2
ERR_FILE_NOT_FOUND=3
ERR_ALREADY_ATTACHED=4
ERR_ALREADY_MOUNTED=5
ERR_NOT_MOUNTED=6
ERR_ATTACHED_NOT_MOUNTED=7
ERR_NOT_FORMATTED=8
ERR_BAD_FILE_EXT=9
ERR_UNMOUNT=10
ERR_DEVICE_MISSING=11
ERR_BUSY=12
ERR_TOO_SMALL=13
ERR_INI_SECTION_NOT_FOUND=13

################################################################################
# Usage: str::error <errno>
#
# Print string describing <errno>
################################################################################
str::error() {
  case "${1:-$ERR_GENERAL}" in
    "$ERR_SUCCESS") printf "Success" ;;
    "$ERR_GENERAL") printf 'General error' ;;
    "$ERR_FILE_NOT_FOUND") printf 'File not found' ;;
    "$ERR_ALREADY_ATTACHED") printf 'Already attached' ;;
    "$ERR_ALREADY_MOUNTED") printf 'Already mounted' ;;
    "$ERR_NOT_MOUNTED") printf 'Not mounted' ;;
    "$ERR_ATTACHED_NOT_MOUNTED") printf 'Attached, but failed to mount' ;;
    "$ERR_NOT_FORMATTED") printf 'Not formatted' ;;
    "$ERR_BAD_FILE_EXT") printf 'Invalid file extension (must be .vhdx)' ;;
    "$ERR_UNMOUNT") printf 'Could not unmount' ;;
    "$ERR_DEVICE_MISSING") printf 'Device missing' ;;
    "$ERR_BUSY") printf 'Windows is using the VHD (try ejecting)' ;;
    "$ERR_TOO_SMALL") printf 'Device too small for filesystem' ;;
    *) printf 'Unknown error %s' "${1:-}" ;;
  esac
}

################################################################################
# Usage: str::trim <string>
#
# Prints string with leading/trailing whitespace removed
################################################################################
str::trim() {
  local str="$*"
  str="${str#"${str%%[![:space:]]*}"}"
  str="${str%"${str##*[![:space:]]}"}"
  printf '%s' "$str"
}

################################################################################
# logging functions
#
# Each prints all passed parameters as a string to `stderr`, if the global
# $LOG_LEVEL is set accordingly. See `main` for how $LOG_LEVEL is adjusted.
################################################################################
log::debug() {
  if ((LOG_LEVEL <= LOG_LEVEL_DEBUG)); then
    printf >&2 'DEBUG: [%s] %s\n' "${FUNCNAME[1]}" "$*"
  fi
}

log::info() {
  if ((LOG_LEVEL <= LOG_LEVEL_INFO)); then
    #printf >&2 'INFO: [%s] %s\n' "${FUNCNAME[1]}" "$*"
    printf >&2 '%s\n' "$*"
  fi
}

log::warning() {
  if ((LOG_LEVEL <= LOG_LEVEL_WARN)); then
    printf >&2 'WARNING: [%s] %s\n' "${FUNCNAME[1]}" "$*"
  fi
}

log::error() {
  if ((LOG_LEVEL <= LOG_LEVEL_ERROR)); then
    printf >&2 'ERROR: [%s] %s\n' "${FUNCNAME[1]}" "$*"
  fi
}

log::critical() {
  if ((LOG_LEVEL <= LOG_LEVEL_CRITICAL)); then
    printf >&2 'CRITICAL: [%s] %s\n' "${FUNCNAME[1]}" "$*"
  fi
}

################################################################################
# Usage: array::sort <params>
#
# Prints each parameter in sorted order
################################################################################
array::sort() { printf '%s\n' "$@" | LC_ALL=C sort; }

################################################################################
# Usage: array::diff <array1> <array2>
#
# Prints elements that exist in array2, which do not exist in array1.
# Arrays are passed by name.
################################################################################
array::diff() {
  local -n arr1=$1
  local -n arr2=$2
  comm -13 <(array::sort "${arr1[@]}") <(array::sort "${arr2[@]}")
}

################################################################################
# Usage: path::win::is_extlen <winpath>
#
# Returns success if <winpath> includes the Extended Length Prefix.
# <https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file>
################################################################################
path::win::is_extlen() {
  local s="${1:-}"
  [[ "${s:0:4}" == "\\\\?\\" ]]
}

################################################################################
# Usage: path::win::strip_extlen <winpath>
#
# Prints <winpath>, omitting the Extended Length Prefix if one exists.
################################################################################
path::win::strip_extlen() {
  local path="${1:-}"
  if path::win::is_extlen "$path"; then
    printf '%s\n' "${path:4}"
  else
    printf '%s\n' "$path"
  fi
}

################################################################################
# Usage: path::win::add_extlen <winpath>
#
# Prints <winpath>, adding the Extended Length Prefix if none exists.
################################################################################
path::win::add_extlen() {
  local path="${1:-}"
  if path::win::is_extlen "$path" || path::win::is_unc "$path"; then
    printf '%s\n' "$path"
  else
    printf '%s\n' "\\\\?\\$path"
  fi
}

################################################################################
# Usage: path::win::is_unc <winpath>
#
# Returns success if <winpath> is a UNC path e.g. `\\somemachine\file.txt`
################################################################################
# shellcheck disable=SC1003
path::win::is_unc() { ! path::win::is_extlen && [[ "${1:0:2}" == '\\' ]]; }

################################################################################
# Usage: path::unix::tilde <unixpath>
#
# Prints <unixpath>, expanding the `~` character to `$HOME`
################################################################################
path::unix::tilde() {
  local path="${1:-}"
  [[ -n "$path" ]] || return 1
  [[ -n "${HOME:-/root}" ]] || return 1
  # FIXME: doesn't handle ~user

  if [[ $path =~ ^~ ]]; then
    printf '%s\n' "${HOME:-/root}${path:1}"
  else
    printf '%s\n' "$path"
  fi
}

################################################################################
# Usage: path::is_win <path>
#
# Returns success if <path> is a Windows path.
################################################################################
path::is_win() {
  local path="${1:-}"
  [[ -n "$path" ]] || return 1
  path::win::is_extlen "$path" \
    || [[ $path =~ ^[a-zA-Z]:\\ ]] \
    || [[ $path =~ ^\.\\ ]]
}

################################################################################
# Usage: path::to_win [options] <path>
#
# Prints path, converting it to Windows format.
#
# [options]
#
# -a  Convert path to absolute
# -e  Add the Extended Length Prefix
################################################################################
path::to_win() {
  local OPTIND rc absolute=false extlen=false
  while getopts 'ae' flag; do
    case "${flag}" in
      a) absolute=true ;;
      e) extlen=true ;;
      *)
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local path="${1:-}"
  if [[ -z "$path" ]]; then
    return 1
  fi
  shift 1

  if ! path::is_win "$path"; then
    path="$(path::unix::tilde "$path")"
    if $absolute; then
      path="$(wslpath -wa "$path")"
    else
      path="$(wslpath -w "$path")"
    fi
  fi

  if $extlen; then
    path="$(path::win::add_extlen "$path")"
  else
    path="$(path::win::strip_extlen "$path")"
  fi

  printf '%s\n' "$path"
}

################################################################################
# Usage: path::to_unix [options] <path>
#
# Prints <path>, converting it to "unix" format.
#
# [options]
#
# -a  Convert path to absolute
# -e  Add the Extended Length Prefix
################################################################################
path::to_unix() {
  local OPTIND rc absolute=false
  while getopts 'a' flag; do
    case "${flag}" in
      a) absolute=true ;;
      *)
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local path="${1:-}"
  if [[ -z "$path" ]]; then
    return 1
  fi
  shift 1

  if path::is_win "$path"; then
    path=$(wslpath -u "$(path::win::strip_extlen "$path")")
  else
    path="$(path::unix::tilde "$path")"
  fi

  if $absolute; then path="$(realpath -sm "$path")"; fi

  printf '%s\n' "$path"
}

################################################################################
# Usage: ini::is_section <line>
#
# Return success if <line> is a section, and print it's name
################################################################################
ini::is_section() {
  local line="${1:-}"
  local len="${#line}"
  if [[ "${line:0:1}" == "[" ]] && [[ "${line:$((len - 1)):1}" == "]" ]]; then
    printf '%s\n' "${line:1:$((len - 2))}"
    return 0
  fi
  return 1
}

################################################################################
# Usage: ini::read_section <output> <section> <file>
#
# Read values from <section> of <file> and store into <output>
# <output> is a name reference to an associative array
################################################################################
ini::read_section() {
  local -n output=${1:-}
  local section=${2:-}
  [[ -n "$section" ]] || return $ERR_ARGS
  local file=${3:-}
  [[ -n "$file" ]] || return $ERR_ARGS
  [[ -f "$file" ]] || return $ERR_FILE_NOT_FOUND

  local found=false
  while read -r line; do
    # skip blank lines
    [[ -n "$line" ]] || continue

    # is this our target section? sections names are vhd's, so convert each end to unix to
    # normalize the test (so vhd's can be referenced by any path format)
    if [[ "$(path::to_unix "$(ini::is_section "$line")")" == "$(path::to_unix "$section")" ]]; then
      # we found our target section
      output['section']="$(str::trim "$section")"
      found=true
      continue
    elif $found && ini::is_section "$line" >/dev/null; then
      # we hit another section after finding ours. so we're done.
      return 0
    elif $found; then
      # we're in a line in our target section. so assign key and value.
      local key value
      key=$(cut -d'=' -f 1 <<<"$line")
      value=$(cut -d'=' -f 2 <<<"$line")
      # shellcheck disable=SC2034
      output[$(str::trim "$key")]="$(str::trim "$value")"
      continue
    fi
  done <"$file"

  # success if we found our section, otherwise error
  if ! $found; then
    return $ERR_INI_SECTION_NOT_FOUND
  fi
}

################################################################################
# ini::list_sections <inifile>
#
# Print name of each ini section in <inifile>
################################################################################
ini::list_sections() {
  local file=${1:-}
  [[ -n "$file" ]] || return $ERR_ARGS
  [[ -f "$file" ]] || return $ERR_FILE_NOT_FOUND

  local section
  while read -r line; do
    if section=$(ini::is_section "$line"); then
      printf '%s\n' "$section"
    fi
  done <"$file"
}

################################################################################
# fstype::is_fuse <fstype>
#
# Return success if <fstype> is a fuse filesystem (i.e. requires manual mount)
################################################################################
fstype::is_fuse() {
  local fstype="${1:-}"
  [[ -n "$fstype" ]] || return 1

  local list=("exfat" "ntfs")
  for x in "${list[@]}"; do
    if [[ "$fstype" == "$x" ]]; then return 0; fi
  done
  return 1
}

################################################################################
# fstype::is_win <fstype>
#
# Return success if <fstype> is a windows filesystem (i.e. requires a partition)
################################################################################
fstype::is_win() {
  local fstype="${1:-}"
  [[ -n "$fstype" ]] || return 1

  local list=("exfat" "msdos" "ntfs" "vfat")
  for x in "${list[@]}"; do
    if [[ "$fstype" == "$x" ]]; then return 0; fi
  done
  return 1
}

################################################################################
# Usage: sys::wsl <parameters>
#
# Executes `wsl.exe <parameters>` and returns smarter errors codes.
################################################################################
sys::wsl() {
  # XXX: Due to WSL interop, output from `wsl.exe` contains a NULL between every character.
  PATH=$PATH:"/mnt/c/WINDOWS/system32" out="$(wsl.exe "$@" 2>&1 | tr -d '\0')"
  local rc=$?
  log::debug "wsl.exe $* returned $rc"
  log::debug "$out"
  if ((rc != 0)); then
    if grep -q "WSL_E_USER_VHD_ALREADY_ATTACHED" <<<"$out"; then
      return $ERR_ALREADY_ATTACHED
    elif grep -q "ERROR_FILE_NOT_FOUND" <<<"$out"; then
      return $ERR_FILE_NOT_FOUND
    elif grep -q "ERROR_PATH_NOT_FOUND" <<<"$out"; then
      return $ERR_FILE_NOT_FOUND
    elif grep -q "it is being used by another process" <<<"$out"; then
      return $ERR_BUSY
    #elif grep -q "The disk was attached but failed to mount: No such device" <<<"$out"; then
    #  return $ERR_ATTACHED_NOT_MOUNTED
    elif grep -q "attached but failed to mount" <<<"$out"; then
      return $ERR_ATTACHED_NOT_MOUNTED
    else
      return $ERR_GENERAL
    fi
  fi
}

################################################################################
# sys::mountpoint_from_device <device>
#
# Prints the mountpoint for <device>
################################################################################
sys::mountpoint_from_device() {
  local device="${1:-}"
  [[ -n "$device" ]] || return $ERR_ARGS
  findmnt -n -f "$device" | cut -d' ' -f 1
}

################################################################################
# Usage: sys::fstype <device>
#
# Print the underlying filesystem type of <device> or `none` on failure.
################################################################################
sys::fstype() {
  local device="${1:-}"
  [[ -n "$device" ]] || return 1
  if [[ "${device:0:5}" != "/dev/" ]]; then device="/dev/$device"; fi
  [[ -b "$device" ]] || return 1

  local fstype rc
  fstype=$(sudo blkid --probe --usages filesystem --match-tag TYPE \
    --output value "$device" 2>/dev/null)
  rc=$?
  if ((rc != 0)) || [[ -z "$fstype" ]]; then return 1; fi
  printf '%s\n' "$fstype"
}

################################################################################
# Usage: sys::devices
#
# Prints path of each block device, skipping partitions e.g. `/dev/sdd1`.
################################################################################
sys::devices() {
  lsblk --ascii --noheadings --output NAME | grep -vE "^\`-" | while read -r device_name; do
    printf '/dev/%s\n' "$device_name"
  done
}

################################################################################
# Usage: sys::mount <fstype> <device> <mountpoint> [uid] [gid]
#
# Mount <device> to <mountpoint> using `mount`.
#
# XXX: This is exclusively for fuse filesystems. The WSL kernel doesn't ship
# with NTFS/exfat support by default; WSL can only attach the device, not mount it.
# So we rely on the FUSE userland driver and `mount` it ourselves .
################################################################################
sys::mount() {
  local fstype="${1:-}"
  [[ -n "$fstype" ]] || return 1
  local device="${2:-}"
  [[ -n "$device" ]] || return 1
  local mountpoint="${3:-}"
  [[ -n "$mountpoint" ]] || return 1
  local uid="${4:-}"
  local gid="${5:-}"

  if [[ "${device:0:5}" != "/dev/" ]]; then device="/dev/$device"; fi

  mkdir -p "$mountpoint" || return 1

  args=()
  if [[ "${fstype:-}" == "exfat" ]]; then
    args+=("-t" "exfat-fuse")
  elif [[ "${fstype:-}" == "ntfs" ]]; then
    args+=("-t" "ntfs-3g")
  fi

  if [[ -n "${uid:-}" ]]; then
    local opts="uid=$uid"
    if [[ -n "${gid:-}" ]]; then opts="${opts},gid=$gid"; fi
    args+=("-o" "$opts")
  fi

  args+=("$device" "$mountpoint")
  log::debug "sudo mount ${args[*]}"
  if ! out=$(sudo mount "${args[@]}"); then
    log::debug "$out"
    return 1
  fi
}

################################################################################
# Usage: sys::unmount <device>
#
# Unmount <device> using `umount`.
################################################################################
sys::unmount() {
  local device="${1:-}"
  [[ -n "$device" ]] || return 1
  sudo umount --all-targets "$device" >/dev/null 2>&1 || return $ERR_UNMOUNT
}

################################################################################
# Usage: sys::is_mounted <mountpoint>
#
# Return success if <mountpoint> is mounted
################################################################################
sys::is_mounted() {
  local mountpoint
  mountpoint="${1:-}"
  [[ -n "$mountpoint" ]] || return 1

  local device_name
  device_name="$(findmnt -n -f "$mountpoint" | cut -d' ' -f 2 | cut -b6-)" || return 1
  [[ -n "$device_name" ]] || return 1

  printf '/dev/%s\n' "$device_name"
}

################################################################################
# Usage: sys::filesystems
#
# Print supported filesystems, one per line.
################################################################################
sys::filesystems() {
  gen() {
    while read -ra vals; do
      [[ "${vals[0]}" == "nodev" ]] && continue
      if PATH=/sbin:/usr/sbin command -v "mkfs.${vals[0]}" >/dev/null 2>&1; then
        printf '%s\n' "${vals[0]}"
      else
        log::info "mkfs.${vals[0]} not found (package not installed?)"
      fi
    done </proc/filesystems

    # fuse drivers
    for fs in ntfs exfat-fuse; do
      if PATH=/sbin:/usr/sbin command -v "mount.$fs" >/dev/null 2>&1; then
        if [[ "$fs" == "exfat-fuse" ]]; then
          printf 'exfat\n'
        else
          printf '%s\n' "$fs"
        fi
      else
        log::info "mount.$fs not found (package not installed?)"
      fi
    done
  }
  gen | sort -d
}

################################################################################
# Usage: sys::requirements
#
# Check system requirements and log errors if we don't meet them.
################################################################################
sys::requirements() {
  requirements=('sudo' 'qemu-img' 'lsblk' 'findmnt')
  for requirement in "${requirements[@]}"; do
    if ! command -v "$requirement" >/dev/null 2>&1; then
      log::error "Required program missing $requirement"
      log::error "Please see Linux requirements in README.md"
      return 1
    fi
  done
  log::debug "All requirements satisfied."
}

################################################################################
# Usage: vhd::valid_ext <vhd>
#
# Returns success if <vhd> has a valid file extension i.e. ".vhdx"
################################################################################
vhd::valid_ext() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  filename="$(basename "$(path::to_unix "$vhd")")"
  [[ -n "$filename" ]] && [[ "${filename##*.}" == "vhdx" ]]
}

################################################################################
# Usage: vhd::unixpath <vhd>
#
# Prints path to <vhd> in "unix" format.
################################################################################
vhd::unixpath() { path::to_unix -a "${1:-}"; }

################################################################################
# Usage: vhd::winpath <vhd>
#
# Prints path to <vhd> in Windows format (including the Extended Length Prefix).
################################################################################
vhd::winpath() { path::to_win -e "${1:-}"; }

################################################################################
# Usage: vhd::name <vhd>
#
# Prints the "name" of the vhd; it's unix basename minus extension. The name is
# as part of the mountpoint.
#
# Example: `C:\foobar.vhdx` will have the name `foobar`.
################################################################################
vhd::name() {
  filename=$(basename "$(vhd::unixpath "${1:-}")")
  printf '%s\n' "$(basename "$filename" ".${filename#*.}")"
}

################################################################################
# Usage: vhd::mountpoint <vhd>
#
# Prints the mountpoint of <vhd> (whether it's mounted or not)
#
# Example: `C:\foobar.vhdx` will have a mountpath of `/mnt/wsl/foobar`.
################################################################################
vhd::mountpoint() { printf '%s/%s\n' "$MOUNT_ROOT" "$(vhd::name "${1:-}")"; }

################################################################################
# Usage: vhd::exists <vhd>
#
# Returns success if the <vhd> file exists.
################################################################################
vhd::exists() {
  local path="${1:-}"
  [[ -n "$path" ]] || return 1
  if [[ ! -f "$(vhd::unixpath "$path")" ]]; then
    log::debug "$path: $(str::error $ERR_FILE_NOT_FOUND)"
    return 1
  fi
}

################################################################################
# Usage: vhd::is_mounted <vhd>
#
# Returns success if the <vhd> is mounted, and prints the device it's mounted to
################################################################################
vhd::is_mounted() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1

  local mountpoint
  mountpoint="$(vhd::mountpoint "$vhd")" || return 1

  [[ -n "$mountpoint" ]] || return 1
  sys::is_mounted "$mountpoint"
}

################################################################################
# Usage: vhd::chown <vhd> [user] [group]
#
# Changes ownership of <vhd>'s mountpoint.
#
# XXX: <vhd> should be mounted first, but that's callers responsibility.
################################################################################
vhd::chown() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  local user="${2:-}"
  local group="${3:-}"

  if [[ -n "$user" ]]; then
    sudo chown "$user" "$(vhd::mountpoint "$vhd")" >/dev/null 2>&1 || return 1
  fi

  if [[ -n "$group" ]]; then
    sudo chgrp "$group" "$(vhd::mountpoint "$vhd")" >/dev/null 2>&1 || return 1
  fi
}

################################################################################
# vhd::mount [options] <vhd>
#
# options
# -u <uid>
# -g <gid>
# -p <partition>
################################################################################
vhd::mount() {
  local OPTIND rc uid gid partition fstype
  while getopts 'u:g:p:' flag; do
    case "${flag}" in
      u) uid="$OPTARG" ;;
      g) gid="$OPTARG" ;;
      p) partition="$OPTARG" ;;
      *)
        return $ERR_ARGS
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return $ERR_ARGS

  # does the backing file exist?
  vhd::exists "$vhd" || return $ERR_FILE_NOT_FOUND

  # is it already mounted?
  local device
  if device=$(vhd::is_mounted "$vhd"); then
    printf '%s\n' "$device"
    return $ERR_ALREADY_MOUNTED
  fi

  # it's not mounted, but might be attached.
  # it's safe to unmount and reattach so we can determine the device.
  vhd::unmount "$vhd" || :
  device="$(vhd::attach "$vhd")" || return $?

  # if we didn't specify a partition, attempt to find one
  if [[ -z "${partition:-}" ]]; then
    log::debug "$vhd: No partition specified, probing..."
    for i in {1..128}; do
      if [[ -b "${device}$i" ]]; then
        partition="$i"
        break
      fi
    done
  fi

  # if we still don't have a partition, assign it 0 (whole device).
  # otherwise switch the device to use the partition.
  if [[ -z "${partition:-}" ]]; then
    log::debug "$vhd: No partition found, default to 0 (whole device)"
    partition=0
  else
    device="${device}${partition}"
    log::debug "$vhd: Found partition $partition, switching device to $device"
  fi

  # what's the filesystem type?
  log::debug "$vhd: probing filesystem on $device"
  fstype=$(sys::fstype "$device")
  if [[ "${fstype:-}" == "none" ]] || [[ -z "${fstype:-}" ]]; then
    return $ERR_NOT_FORMATTED
  fi

  log::debug "$vhd: $fstype found on $device"
  if fstype::is_fuse "$fstype"; then
    # this filesystem requires manually mounting
    log::debug "$vhd: $device is formatted with $fstype, fuse mount"
    sys::mount "$fstype" "$device" "$(vhd::mountpoint "$vhd")" \
      "${uid:-}" "${gid:-}" || return $?
  else
    # it's not a fuse filesystem
    log::debug "$vhd: $device is formatted with $fstype, mount with wsl.exe"
    args=("--mount")
    if ((partition != 0)); then args+=("--partition" "$partition"); fi
    args+=("--vhd" "--name" "$(vhd::name "$vhd")" "$(vhd::winpath "$vhd")")
    if [[ -n "${uid:-}" ]] && [[ "${fstype:-}" == "vfat" ]]; then
      args+=("--options" "uid=$uid,gid=${gid:-$uid}")
    fi
    sys::wsl "${args[@]}" || return $?
  fi

  printf '%s\n' "$device"
}

################################################################################
# Usage: vhd::attach <vhd>
#
# Attaches <vhd> and prints the device on success.
# The device will be exposed to WSL, but not mounted.
################################################################################
vhd::attach() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  local device pre post

  vhd::exists "$vhd" || return $ERR_FILE_NOT_FOUND

  if device=$(vhd::is_mounted "$vhd"); then
    printf '%s\n' "$device"
    return $ERR_ALREADY_MOUNTED
  fi

  # shellcheck disable=SC2034
  readarray -t pre < <(sys::devices)
  sys::wsl --mount --bare --vhd --name "$(vhd::name "$vhd")" "$(vhd::winpath "$vhd")" || return $?

  # shellcheck disable=SC2034
  readarray -t post < <(sys::devices)
  printf '%s\n' "$(array::diff pre post | head -n 1)"
}

################################################################################
# Usage: vhd::mountpoints
#
# Prints the mountpoint of every mounted vhd.
################################################################################
vhd::mountpoints() {
  local mountpoint
  while read -ra arr; do
    mountpoint="${arr[1]}"
    if [[ "${mountpoint:0:9}" == "${MOUNT_ROOT}/" ]]; then
      printf '%s\n' "${arr[1]}"
    fi
  done </proc/mounts
}

################################################################################
# Usage: vhd::unmount [vhd]
#
# Unmounts all vhd's, or just [vhd] if specified.
################################################################################
vhd::unmount() {
  local vhd="${1:-}"
  local device
  local fstype

  # No vhd passed....so unmount everything.
  if [[ -z "$vhd" ]]; then
    while read -r mountpoint; do
      device=$(sys::is_mounted "$mountpoint") || continue
      fstype=$(sys::fstype "$device") || continue
      if [[ "$fstype" == "none" ]]; then continue; fi
      if fstype::is_fuse "$fstype"; then
        sys::unmount "$mountpoint" || :
      fi
    done < <(vhd::mountpoints)
    sys::wsl --unmount || :
    return 0
  fi

  vhd::valid_ext "$vhd" || return $ERR_BAD_FILE_EXT

  # it's not mounted, but might be attached.
  # we're safe to detach with wsl.exe and exit.
  device=$(vhd::is_mounted "$vhd") || {
    sys::wsl --unmount "$(vhd::winpath "$vhd")" || :
    return 0
  }

  # it's mounted, so determine the filesystem
  fstype=$(sys::fstype "$device") || :

  # no filesystem. safe to detach.
  if [[ "$fstype" == "none" ]]; then
    sys::wsl --unmount "$(vhd::winpath "$vhd")" || :
    return 0
  fi

  if fstype::is_fuse "$fstype"; then
    sys::unmount "$(vhd::mountpoint "$vhd")" || :
  fi
  sys::wsl --unmount "$(vhd::winpath "$vhd")" || :
}

################################################################################
# Usage: vhd::create <vhd> <size_in_mb>
#
# Creates <vhd> with `qemu-img`.
################################################################################
vhd::create() {
  local vhd="${1:-}"
  [[ -n "$vhd" ]] || return 1
  local size_in_mb="${2:-}"
  [[ -n "$size_in_mb" ]] || return 1

  if [[ -f "$(vhd::unixpath "$vhd")" ]]; then
    log::debug "$vhd: already exists"
    return 1
  fi

  vhd::valid_ext "$vhd" || return $ERR_BAD_FILE_EXT

  vhd::unmount "$vhd" || :

  args=(
    "create" "-f" "vhdx"
    "$(vhd::unixpath "$vhd")"
    "${size_in_mb}M"
  )

  out="$(qemu-img "${args[@]}" 2>&1)"
  rc=$?
  log::debug "returned $rc: qemu-img ${args[*]}"
  log::debug "output: $out"
  if ((rc != 0)); then
    log::error "qemu-img returned $rc"
    log::error "$out"
    return $rc
  fi
}

################################################################################
# Usage: vhd::format [options] <vhd>
#
# options
# -t <fstype> (default: ext4)
# -p <partition> (default: 0)
#
# Partition 0 means format the whole device.
################################################################################
vhd::format() {
  local OPTIND rc fstype partition vhd out
  while getopts 't:p:' flag; do
    case "${flag}" in
      t) fstype="$OPTARG" ;;
      p) partition="$OPTARG" ;;
      *)
        return $ERR_ARGS
        ;;
    esac
  done

  shift $((OPTIND - 1))
  vhd="${1:-}"
  [[ -n "$vhd" ]] || return $ERR_ARGS

  # set default fstype
  [[ -n "${fstype:-}" ]] || fstype="ext4"

  log::debug "$vhd: fstype=${fstype:-}, partition=${partition:-}"

  # unmount and attach
  vhd::unmount "$vhd" || :
  device=$(vhd::attach "$vhd") || {
    rc=$?
    log::debug "vhd::attach failed with $(str::error $rc)"
    return $rc
  }

  # partition wasn't specified, so choose sane default.
  # in particular, filesystems need to be on a partition
  # if they ever want to be read on Windows.
  if [[ -z "${partition:-}" ]]; then
    fstype::is_win "$fstype" && partition=1 || partition=0
  fi

  if ((partition != 0)); then
    # create the partition with fdisk
    out=$(printf 'n\np\n%s\n\n\nt 1\n7\nw\n' "$partition" | sudo fdisk "$device")
    rc=$?
    if ((rc != 0)); then
      log::debug "$vhd: fdisk $device failed with $rc"
      return $ERR_GENERAL
    fi
    device="${device}${partition}"
  fi

  local mkfsargs=("-t" "$fstype")
  if [[ "$fstype" == "ntfs" ]]; then
    mkfsargs+=("-f")
  fi
  mkfsargs+=("$device")
  out=$(sudo mkfs "${mkfsargs[@]}" 2>&1) || {
    rc=$?
    log::debug "returned $rc: sudo mkfs ${mkfsargs[*]}"
    log::debug "$out"
    if grep -q "too small" <<<"$out"; then
      return $ERR_TOO_SMALL
    else
      return $ERR_GENERAL
    fi
  }

  # unmount and exit
  vhd::unmount "$vhd" || :
}

################################################################################
# vhd::up <inifile> [vhd]
#
# Mounts each VHD in <inifile> or the VHD specified by [vhd].
################################################################################
vhd::up() {
  handle_vhd() {
    local -n data=$1
    local vhd="${data["vhd"]:-}"
    local fstype="${data["fstype"]:-}"
    local size_in_mb="${data["size_in_mb"]:-}"
    local uid="${data["uid"]:-1000}"
    local gid="${data["gid"]:-1000}"
    local partition="${data["partition"]:-}"
    local rc
    local device

    local mountargs=()
    if [[ -n "${uid:-}" ]]; then mountargs+=("-u" "$uid"); fi
    if [[ -n "${gid:-}" ]]; then mountargs+=("-g" "$gid"); fi
    if [[ -n "${partition:-}" ]]; then mountargs+=("-p" "$partition"); fi
    mountargs+=("$vhd")

    local formatargs=()
    if [[ -n "${fstype:-}" ]]; then formatargs+=("-t" "$fstype"); fi
    if [[ -n "${partition:-}" ]]; then formatargs+=("-p" "$partition"); fi
    formatargs+=("$vhd")

    device=$(vhd::mount "${mountargs[@]}") || {
      local -r rc=$?
      case $rc in
        "$ERR_ALREADY_MOUNTED")
          # do nothing
          ;;
        "$ERR_FILE_NOT_FOUND")
          vhd::create "$vhd" "$size_in_mb" || {
            local -r rc2=$?
            log::error "vhd::create($vhd,$size_in_mb) failed with $(str::error $rc2)"
            return $rc2
          }

          log::info "$vhd: Created ${size_in_mb}M image."

          vhd::format "${formatargs[@]}" || {
            local -r rc2=$?
            log::error "vhd::format ${formatargs[*]} failed with $(str::error $rc2)"
            return $rc2
          }

          log::info "$vhd: Formatted with $fstype."

          device=$(vhd::mount "${mountargs[@]}") || {
            local -r rc2=$?
            log::error "vhd::mount ${mountargs[*]} failed with $(str::error $rc2)"
            return $rc2
          }
          ;;
        *) return $rc ;;
      esac
    }
    vhd::chown "$vhd" "${uid:-}" "${gid:-}" || :
    printf '%s\n' "$device"
  }

  local config_file="${1:-}"
  [[ -n "$config_file" ]] || return $ERR_ARGS
  [[ -f "$config_file" ]] || {
    log::debug "$config_file: $(str::error "$ERR_FILE_NOT_FOUND")"
    return $ERR_FILE_NOT_FOUND
  }
  local vhd="${2:-}"

  # first grab globals.
  declare -A global_data
  ini::read_section global_data "global" "$config_file"

  # build a list of section names
  local vhds=()
  if [[ -n "$vhd" ]]; then
    vhds+=("$vhd")
  else
    readarray -t vhds < <(ini::list_sections "$config_file")
  fi

  # iterate each section.
  for vhd in "${vhds[@]}"; do
    [[ "$vhd" == "global" ]] && continue

    # create new section_data and populate with global_data
    declare -A section_data=()
    section_data['vhd']="$vhd"
    for key in "${!global_data[@]}"; do
      # shellcheck disable=SC2034
      section_data["$key"]="${global_data["$key"]}"
    done

    # now read the section values and add them to section_data
    ini::read_section section_data "$vhd" "$config_file" || {
      log::debug "$config_file: Could not read ini section [$vhd]"
      continue
    }

    # now do something with each session_data structure
    local device
    device="$(handle_vhd section_data)" || {
      log::error "$vhd: handle_vhd failed with $?"
      continue
    }
    log::info "$vhd: Mounted $device -> $(sys::mountpoint_from_device "$device")"
  done
}

################################################################################
# vhd::down <inifile> [vhd]
#
# Unmount each VHD in <inifile> or the VHD specified by [vhd].
################################################################################
vhd::down() {
  local config_file="${1:-}"
  [[ -n "$config_file" ]] || return $ERR_ARGS
  [[ -f "$config_file" ]] || {
    log::debug "$config_file: $(str::error "$ERR_FILE_NOT_FOUND")"
    return $ERR_FILE_NOT_FOUND
  }
  local vhd="${2:-}"

  local vhds=()
  if [[ -n "$vhd" ]]; then
    vhds+=("$vhd")
  else
    readarray -t vhds < <(ini::list_sections "$config_file")
  fi

  for vhd in "${vhds[@]}"; do
    [[ "$vhd" == "global" ]] && continue
    vhd::unmount "$vhd"
    log::info "$(path::to_win "$vhd"): Unmounted"
  done
}

################################################################################
# cli functions.
#################################################################################

wsl-vhd-up() {
  log::debug "wsl-vhd up $*"
  usage() {
    cat <<EOF
Usage: $PROG_NAME up [OPTIONS] [VHD]

Mount all VHD's in /etc/wsl-vhd.conf, or the [VHD] specified.
If a VHD doesn't exist, it will be created and formatted.

OPTIONS

-f  <inifile>   Read from <inifile> (default: /etc/wsl-vhd.conf)
-h              This message
EOF
  }

  local OPTIND rc
  local inifile="/etc/wsl-vhd.conf"

  while getopts 'f:h' flag; do
    case "${flag}" in
      f) inifile="$OPTARG" ;;
      *)
        usage
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))
  local -r vhd="${1:-}"

  local rc
  vhd::up "${inifile}" "${vhd:-}" || {
    rc=$?
    log::error "$inifile: $(str::error $rc)"
    return $rc
  }
}

wsl-vhd-down() {
  log::debug "wsl-vhd down $*"
  usage() {
    cat <<EOF
Usage: $PROG_NAME down [OPTIONS] [name]

Unmount all VHD's in /etc/wsl-vhd.conf, or the VHD specified by [name].

OPTIONS

-f  <inifile>   Read from <inifile> (default: /etc/wsl-vhd.conf)
-h              This message
EOF
  }

  local OPTIND rc
  local inifile="/etc/wsl-vhd.conf"

  while getopts 'f:h' flag; do
    case "${flag}" in
      f) inifile="$OPTARG" ;;
      *)
        usage
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))
  local name="${1:-}"

  vhd::down "${inifile}" "${name:-}" || {
    rc=$?
    log::error "$inifile: $(str::error $rc)"
    return $rc
  }
}

wsl-vhd-create() {
  usage() {
    cat <<EOF
Usage: $PROG_NAME <VHD> <SIZE_IN_MB>

Create a new <VHD>, <SIZE_IN_MB> megabytes large. 
This simply creates the image, not the filesystem.

EXAMPLES

$ $PROG_NAME create /mnt/c/code.vhdx
EOF
  }

  local OPTIND rc
  while getopts 'h' flag "$@"; do
    case "${flag}" in
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local vhd="${1:-}"
  local size_in_mb="${2:-}"
  shift 2

  if [[ -z "$vhd" ]] || [[ -z "$size_in_mb" ]]; then
    usage
    return 1
  fi

  local rc
  vhd::create "$vhd" "$size_in_mb" || {
    rc=$?
    log::error "$vhd: Failed to create ${size_in_mb} image: $(str::error $rc)"
    return $rc
  }

  log::info "$vhd: Successfully created ${size_in_mb}M image"
}

wsl-vhd-format() {
  log::debug "wsl-vhd format $*"
  usage() {
    cat <<EOF
Usage: $PROG_NAME format <DEVICE> <FS>

Format <DEVICE> with <FS>

Supported filesystems: $(sys::filesystems | tr '\n' ' ')
EOF
  }

  local OPTIND rc
  while getopts 'h' flag "$@"; do
    case "${flag}" in
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local device="${1:-}"
  local fstype="${2:-}"
  shift 2

  if [[ -z "$device" ]] || [[ -z "$fstype" ]]; then
    usage
    return 1
  fi

  local rc
  vhd::format "$vhd" >/dev/null || {
    rc=$?
    log::error "$vhd: $(str::error $rc)"
    return $rc
  }

  log::info "$vhd: Formatted as $fstype"
}

wsl-vhd-mount() {
  log::debug "wsl-vhd mount $*"
  usage() {
    cat <<EOF
Usage: $PROG_NAME mount [OPTIONS] <VHD>

Mounts the disk image located at <VHD> and prints the mountpoint on success.

OPTIONS

-u  <UID>         Change ownership of mountpoint to <uid>
-g  <GID>         Change ownership of mountpoint to <gid>
-p  <PARTITION>   Mount the specified <PARTITION> on <VHD>

EXAMPLES

$ $PROG_NAME mount /mnt/c/code.vhdx
EOF
  }

  local OPTIND rc uid gid partition
  while getopts 'u:g:p:h' flag "$@"; do
    case "${flag}" in
      u)
        uid="${OPTARG}"
        ;;
      g)
        gid="${OPTARG}"
        ;;
      p)
        partition="${OPTARG}"
        ;;
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local vhd="${1:-}"
  shift 1

  if [[ -z "$vhd" ]]; then
    usage
    return 1
  fi

  local mountargs=()
  if [[ -n "${uid:-}" ]]; then mountargs+=("-u" "$uid"); fi
  if [[ -n "${gid:-}" ]]; then mountargs+=("-g" "$gid"); fi
  if [[ -n "${partition:-}" ]]; then mountargs+=("-p" "$partition"); fi
  mountargs+=("$vhd")

  local rc
  device="$(vhd::mount "${mountargs[@]}")" || {
    rc=$?
    if ((rc != ERR_ALREADY_MOUNTED)); then
      log::error "$vhd: $(str::error $rc)"
      return $rc
    fi
  }
  log::info "Mounted to $(vhd::mountpoint "$vhd") using device $device"
}

wsl-vhd-attach() {
  usage() {
    cat <<EOF
Usage: $PROG_NAME attach <VHD>

Attach the disk image <VHD> and prints the device on success.

EXAMPLE

$ $PROG_NAME attach 'C:\\mything.vhdx'
/dev/sdd
EOF
  }

  local OPTIND rc
  while getopts 'h' flag "$@"; do
    case "${flag}" in
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local vhd="${1:-}"
  shift 1

  if [[ -z "$vhd" ]]; then
    usage
    return 1
  fi

  local rc
  device="$(vhd::attach "$vhd")" || {
    rc=$?
    log::error "$vhd: $(str::error $rc)"
    return $rc
  }

  log::info "$vhd: Attached to $device"
  printf '%s\n' "$device"
}

wsl-vhd-unmount() {
  usage() {
    cat <<EOF
Usage: $PROG_NAME unmount [VHD]

Unmount <VHD> or all VHD's
EOF
  }

  local OPTIND rc
  while getopts 'h' flag "$@"; do
    case "${flag}" in
      *)
        usage
        return 1
        ;;
    esac
  done

  shift $((OPTIND - 1))
  local vhd="${1:-}"
  shift 1

  if ! vhd::unmount "$vhd"; then
    log::info "${vhd:-All}: $(str::error "$ERR_UNMOUNT")"
    return $ERR_UNMOUNT
  fi
}

################################################################################
# main
################################################################################

main() {
  usage() {
    cat <<EOF
Usage: $PROG_NAME [GLOBAL-OPTIONS] <COMMAND>

VHD management for WSL. 

GLOBAL OPTIONS

  -h  This message
  -v  Increase verbosity. \`-v\` for debug, \`-vv\` for trace.

COMMANDS

  up            Mount VHD's in \`/etc/wsl-vhd.conf\`, creating and formatting if necessary
  down          Unmount VHD's in \`/etc/wsl-vhd.conf\`

  create        Create new VHD without formatting
  attach        Attach VHD without mounting (aka bare mount)
  mount         Mount VHD
  format        Format VHD
  unmount       Unmount VHD (or all by default)

Pass \`-h\` to any command to view usage e.g. \`$PROG_NAME use -h\`
EOF
  }

  local OPTIND rc
  while getopts 'hqv' flag; do
    case "${flag}" in
      v) ((LOG_LEVEL -= 10)) ;;
      q) ((LOG_LEVEL += 10)) ;;
      *)
        usage
        return 1
        ;;
    esac
  done

  if ((LOG_LEVEL <= LOG_LEVEL_UNSET)); then
    set -x
  fi

  shift $((OPTIND - 1))
  cmd="${1:-}"
  if [[ -z "$cmd" ]]; then
    usage
    return 1
  fi
  shift 1

  if [[ "$cmd" != "requirements" ]] && ! sys::requirements; then
    log::critical "Missing requirements"
    return 1
  fi

  case "$cmd" in
    up) wsl-vhd-up "$@" ;;
    down) wsl-vhd-down "$@" ;;
    create) wsl-vhd-create "$@" ;;
    mount) wsl-vhd-mount "$@" ;;
    attach) wsl-vhd-attach "$@" ;;
    unmount) wsl-vhd-unmount "$@" ;;
    umount) wsl-vhd-unmount "$@" ;;
    format) wsl-vhd-format "$@" ;;
    filesystems) sys::filesystems "$@" ;;
    requirements) sys::requirements "$@" ;;
    test) test::unit "$@" ;;
    *)
      usage
      return 1
      ;;
  esac
}

[[ "${BASH_SOURCE[0]:-}" != "$0" ]] || main "$@"
